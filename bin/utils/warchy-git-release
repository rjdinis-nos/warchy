#!/usr/bin/env bash
set -euo pipefail

# Parse arguments
DRY_RUN=false
VERSION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--tag)
            VERSION="$2"
            shift 2
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -h|--help)
            echo "Usage: warchy-git-release -t VERSION [OPTIONS]"
            echo ""
            echo "Create a git tag and GitHub release"
            echo ""
            echo "Options:"
            echo "  -t, --tag VERSION      Version to release (required)"
            echo "  -d, --dry-run          Show what would be done without making changes"
            echo "  -h, --help             Show this help message"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
    esac
done

# Check if version was provided
if [ -z "$VERSION" ]; then
    echo "Error: Version is required" >&2
    echo "Usage: warchy-git-release -t VERSION [OPTIONS]" >&2
    exit 1
fi

# Strip 'v' prefix if provided
VERSION="${VERSION#v}"

# Check prerequisites
MISSING_DEPS=()

if ! command -v gh &>/dev/null; then
    MISSING_DEPS+=("gh (GitHub CLI)")
fi

if ! command -v jq &>/dev/null; then
    MISSING_DEPS+=("jq")
fi

if [ ${#MISSING_DEPS[@]} -gt 0 ]; then
    echo -e "\e[31mError: Missing required dependencies:\e[0m" >&2
    for dep in "${MISSING_DEPS[@]}"; do
        echo "  - $dep" >&2
    done
    echo ""
    echo "Install missing packages:" >&2
    [ ${#MISSING_DEPS[@]} -eq 2 ] && echo "  warchy-install-pacman-pkgs jq && warchy-install-paru-pkgs github-cli" >&2
    [[ " ${MISSING_DEPS[@]} " =~ " gh (GitHub CLI) " ]] && ! [[ " ${MISSING_DEPS[@]} " =~ " jq " ]] && echo "  warchy-install-paru-pkgs github-cli" >&2
    [[ " ${MISSING_DEPS[@]} " =~ " jq " ]] && ! [[ " ${MISSING_DEPS[@]} " =~ " gh (GitHub CLI) " ]] && echo "  warchy-install-pacman-pkgs jq" >&2
    exit 1
fi

# Check if gh is authenticated
if [ "$DRY_RUN" = false ]; then
    if ! gh auth status &>/dev/null; then
        echo -e "\e[31mError: GitHub CLI is not authenticated\e[0m" >&2
        echo "Please run: gh auth login" >&2
        exit 1
    fi
fi

if [ "$DRY_RUN" = true ]; then
    echo -e "\e[33m[DRY RUN MODE] No changes will be made\e[0m"
    echo ""
fi

echo "Release version: $VERSION"

# Check if we're in a git repository
if ! git -C "$WARCHY_PATH" rev-parse --git-dir &>/dev/null; then
    echo "Error: $WARCHY_PATH is not a git repository" >&2
    exit 1
fi

# Ensure we have full repository history (unshallow if needed)
if [ -f "$WARCHY_PATH/.git/shallow" ]; then
    echo "Repository is shallow, fetching full history..."
    git -C "$WARCHY_PATH" fetch --unshallow --quiet 2>/dev/null || true
fi

# Fetch latest tags from remote
echo "Fetching latest tags from remote..."
git -C "$WARCHY_PATH" fetch --tags --quiet 2>/dev/null || true

# Check for unpushed commits
UNPUSHED_COUNT=$(git -C "$WARCHY_PATH" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
if [ "$UNPUSHED_COUNT" -gt "0" ]; then
    echo -e "\e[33m⚠ Warning: There are $UNPUSHED_COUNT unpushed commit(s) on the current branch\e[0m"
    if [ "$DRY_RUN" = true ]; then
        echo -e "\e[33m⚠ Push these commits before creating a release\e[0m"
        echo ""
        echo "Unpushed commits:"
        git -C "$WARCHY_PATH" log --oneline @{u}..HEAD
        echo ""
    else
        echo -e "\e[33m⚠ Consider pushing these commits before creating a release\e[0m"
    fi
fi

# Get the most recent tag from remote
LATEST_REMOTE_TAG=$(git -C "$WARCHY_PATH" tag --sort=-version:refname 2>/dev/null | head -n 1)
if [ -n "$LATEST_REMOTE_TAG" ]; then
    # Strip 'v' prefix for comparison
    LATEST_VERSION="${LATEST_REMOTE_TAG#v}"
    echo "Latest remote tag: $LATEST_REMOTE_TAG ($LATEST_VERSION)"
else
    LATEST_VERSION=""
    echo "No existing tags found (this will be the first release)"
fi

# Validate that new version is higher than latest remote version
if [ -n "$LATEST_VERSION" ]; then
    # Compare versions using sort -V (version sort)
    HIGHER_VERSION=$(printf "%s\n%s" "$LATEST_VERSION" "$VERSION" | sort -V | tail -n 1)
    
    if [ "$HIGHER_VERSION" = "$LATEST_VERSION" ]; then
        echo -e "\e[31mError: Version $VERSION is not higher than latest remote version $LATEST_VERSION\e[0m" >&2
        exit 1
    elif [ "$VERSION" = "$LATEST_VERSION" ]; then
        echo -e "\e[31mError: Version $VERSION already exists as $LATEST_REMOTE_TAG\e[0m" >&2
        exit 1
    fi
    
    echo -e "\e[32m✔ Version $VERSION is higher than $LATEST_VERSION\e[0m"
fi

# Read current version from file
VERSION_FROM_FILE=$(cat "$WARCHY_PATH/version" 2>/dev/null | tr -d '[:space:]')

# Update version file
if [ "$VERSION" != "$VERSION_FROM_FILE" ]; then
    echo "Version file contains: $VERSION_FROM_FILE"
    echo "Updating version file to: $VERSION"
    
    if [ "$DRY_RUN" = false ]; then
        echo "$VERSION" > "$WARCHY_PATH/version"
        git -C "$WARCHY_PATH" add "$WARCHY_PATH/version"
        
        # Use latest remote tag for commit message if available
        if [ -n "$LATEST_VERSION" ]; then
            git -C "$WARCHY_PATH" commit -m "Bump version from $LATEST_VERSION to $VERSION"
        else
            git -C "$WARCHY_PATH" commit -m "Set initial version to $VERSION"
        fi
        echo -e "\e[32m✔ Updated version file and committed change\e[0m"
    else
        echo -e "\e[33m[DRY RUN] Would update version file from $VERSION_FROM_FILE to $VERSION\e[0m"
        if [ -n "$LATEST_VERSION" ]; then
            echo -e "\e[33m[DRY RUN] Would commit: Bump version from $LATEST_VERSION to $VERSION\e[0m"
        else
            echo -e "\e[33m[DRY RUN] Would commit: Set initial version to $VERSION\e[0m"
        fi
    fi
else
    echo "Version file already contains: $VERSION"
fi

# Check if tag already exists
TAG_EXISTS=false
if git -C "$WARCHY_PATH" rev-parse "v$VERSION" &>/dev/null; then
    TAG_EXISTS=true
    echo "Tag v$VERSION already exists" >&2
    
    if [ "$DRY_RUN" = false ]; then
        # Ask if user wants to delete and recreate
        read -p "Delete and recreate tag? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git -C "$WARCHY_PATH" tag -d "v$VERSION"
            echo "Deleted existing tag v$VERSION"
            TAG_EXISTS=false
        else
            exit 1
        fi
    else
        echo -e "\e[33m[DRY RUN] Would prompt to delete existing tag v$VERSION\e[0m"
        TAG_EXISTS=false
    fi
fi

# Create the tag
if [ "$DRY_RUN" = true ]; then
    echo -e "\e[33m[DRY RUN] Would create tag: v$VERSION\e[0m"
    echo -e "\e[33m[DRY RUN] Tag message: Release v$VERSION\e[0m"
else
    git -C "$WARCHY_PATH" tag -a "v$VERSION" -m "Release v$VERSION"
    echo -e "\e[32m✔ Created tag v$VERSION\e[0m"
fi

# Ask if user wants to push
PUSHED=false
if [ "$DRY_RUN" = false ]; then
    read -p "Push tag to remote? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Check if tag exists on remote
        if git -C "$WARCHY_PATH" ls-remote --tags origin "refs/tags/v$VERSION" | grep -q "v$VERSION"; then
            echo "Tag v$VERSION already exists on remote"
            read -p "Force push to overwrite remote tag? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git -C "$WARCHY_PATH" push origin "v$VERSION" --force
                echo -e "\e[32m✔ Force pushed tag v$VERSION to remote\e[0m"
                PUSHED=true
            else
                echo -e "\e[33m⚠ Skipping tag push\e[0m"
            fi
        else
            git -C "$WARCHY_PATH" push origin "v$VERSION"
            echo -e "\e[32m✔ Pushed tag v$VERSION to remote\e[0m"
            PUSHED=true
        fi
    fi
else
    echo -e "\e[33m[DRY RUN] Would prompt to push tag v$VERSION to remote\e[0m"
    PUSHED=true  # Simulate pushed for dry-run to show release creation
fi

# Check if gh CLI is available for release creation
if command -v gh &>/dev/null && [ "$PUSHED" = true ]; then
    if [ "$DRY_RUN" = false ]; then
        read -p "Create GitHub release? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Check if release already exists
            if gh -R "$(git -C "$WARCHY_PATH" remote get-url origin | sed 's/.*github.com[:/]\(.*\)\.git/\1/')" release view "v$VERSION" &>/dev/null; then
                echo "Release v$VERSION already exists" >&2
                read -p "Delete and recreate release? (y/N): " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    gh -R "$(git -C "$WARCHY_PATH" remote get-url origin | sed 's/.*github.com[:/]\(.*\)\.git/\1/')" release delete "v$VERSION" -y
                    echo "Deleted existing release v$VERSION"
                else
                    exit 0
                fi
            fi
            
            # Create release with auto-generated notes
            echo "Creating GitHub release..."
            if gh release create "v$VERSION" \
                --repo "$(git -C "$WARCHY_PATH" remote get-url origin | sed 's/.*github.com[:/]\(.*\)\.git/\1/')" \
                --title "Release v$VERSION" \
                --generate-notes \
                "$WARCHY_PATH/install.warchy.sh#install.warchy.sh" \
                "$WARCHY_PATH/New-ArchWSL.ps1#New-ArchWSL.ps1" 2>&1; then
                echo -e "\e[32m✔ Created GitHub release v$VERSION with install.warchy.sh and New-ArchWSL.ps1 attached\e[0m"
            else
                echo -e "\e[31mError: Failed to create GitHub release\e[0m" >&2
                echo "Check that the tag v$VERSION exists on remote and try again" >&2
                exit 1
            fi
        fi
    else
        echo -e "\e[33m[DRY RUN] Would prompt to create GitHub release v$VERSION\e[0m"
        echo -e "\e[33m[DRY RUN] Release title: Release v$VERSION\e[0m"
        echo -e "\e[33m[DRY RUN] Would attach: install.warchy.sh\e[0m"
        echo -e "\e[33m[DRY RUN] Would attach: New-ArchWSL.ps1\e[0m"
        echo ""
        
        # Generate preview of release notes
        echo -e "\e[36m=== Release Notes Preview ===\e[0m"
        REPO=$(git -C "$WARCHY_PATH" remote get-url origin | sed 's/.*github.com[:/]\(.*\)\.git/\1/')
        
        # Get all tags sorted by version, excluding the current version if it exists
        ALL_TAGS=$(git -C "$WARCHY_PATH" tag --sort=-version:refname 2>/dev/null)
        
        # Find the previous tag (skip v$VERSION if it exists)
        PREV_TAG=""
        while IFS= read -r tag; do
            if [ "$tag" != "v$VERSION" ]; then
                PREV_TAG="$tag"
                break
            fi
        done <<< "$ALL_TAGS"
        
        if [ -n "$PREV_TAG" ]; then
            echo "Comparing v$VERSION with previous release: $PREV_TAG"
            echo ""
            
            # Determine comparison target: use existing tag if present, otherwise HEAD
            COMPARISON_TARGET="HEAD"
            if git -C "$WARCHY_PATH" rev-parse "v$VERSION" &>/dev/null; then
                COMPARISON_TARGET="v$VERSION"
            fi
            
            # Check if there are any commits between tags
            COMMIT_COUNT=$(git -C "$WARCHY_PATH" rev-list --count "$PREV_TAG..$COMPARISON_TARGET" 2>/dev/null || echo "0")
            
            if [ "$COMMIT_COUNT" -eq "0" ]; then
                echo -e "\e[33mNo new commits since $PREV_TAG\e[0m"
                echo "The release would have no changes."
            else
                echo -e "\e[90m($COMMIT_COUNT commit(s) since $PREV_TAG)\e[0m"
                echo ""
                
                # Try GitHub API first if jq is available
                SHOW_GIT_LOG=true
                if command -v jq &>/dev/null && command -v gh &>/dev/null; then
                    API_RESULT=$(gh api \
                        --method POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        "/repos/$REPO/releases/generate-notes" \
                        -f tag_name="v$VERSION" \
                        -f previous_tag_name="$PREV_TAG" 2>&1 || true)
                    
                    if echo "$API_RESULT" | jq -e '.body' &>/dev/null 2>&1; then
                        API_BODY=$(echo "$API_RESULT" | jq -r '.body')
                        # Check if API only returned the changelog link (no actual commit details)
                        if echo "$API_BODY" | grep -qE '^\*\*Full Changelog\*\*:' && [ $(echo "$API_BODY" | wc -l) -eq 1 ]; then
                            echo -e "\e[90m[No PR-based commits - showing git log]\e[0m"
                            echo ""
                            echo "## What's Changed"
                            echo ""
                            git -C "$WARCHY_PATH" log --pretty=format:"* %s (%h)" --no-decorate "$PREV_TAG..$COMPARISON_TARGET"
                            echo ""
                            echo ""
                            echo "$API_BODY"
                            SHOW_GIT_LOG=false
                        else
                            echo "$API_BODY"
                            SHOW_GIT_LOG=false
                        fi
                    fi
                fi
                
                # Show git log if API didn't work or isn't available
                if [ "$SHOW_GIT_LOG" = true ]; then
                    if ! command -v jq &>/dev/null; then
                        echo -e "\e[90m[jq not installed - showing git log]\e[0m"
                    elif ! command -v gh &>/dev/null; then
                        echo -e "\e[90m[gh CLI not installed - showing git log]\e[0m"
                    else
                        echo -e "\e[90m[GitHub API unavailable - showing git log]\e[0m"
                    fi
                    echo ""
                    echo "## What's Changed"
                    echo ""
                    git -C "$WARCHY_PATH" log --pretty=format:"* %s (%h)" --no-decorate "$PREV_TAG..$COMPARISON_TARGET"
                    echo ""
                    echo ""
                fi
            fi
        else
            echo -e "\e[33mThis would be the first release\e[0m"
            echo ""
            
            COMMIT_COUNT=$(git -C "$WARCHY_PATH" rev-list --count HEAD 2>/dev/null || echo "0")
            DISPLAY_COUNT=$((COMMIT_COUNT < 20 ? COMMIT_COUNT : 20))
            
            echo -e "\e[90m($COMMIT_COUNT total commit(s), showing first $DISPLAY_COUNT)\e[0m"
            echo ""
            echo "## What's Changed"
            echo ""
            git -C "$WARCHY_PATH" log --pretty=format:"* %s (%h)" --no-decorate | head -20
            echo ""
            
            if [ "$COMMIT_COUNT" -gt "20" ]; then
                echo ""
                echo -e "\e[90m... and $((COMMIT_COUNT - 20)) more commits\e[0m"
            fi
        fi
        echo ""
        echo -e "\e[36m=============================\e[0m"
    fi
elif [ "$PUSHED" = false ]; then
    echo -e "\e[33m⚠ Tag not pushed to remote. Push tag to create GitHub release.\e[0m"
elif ! command -v gh &>/dev/null; then
    echo -e "\e[33m⚠ gh CLI not installed. Install with: warchy-install-paru-pkgs github-cli\e[0m"
fi
